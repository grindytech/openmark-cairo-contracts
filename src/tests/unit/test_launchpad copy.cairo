use super::super::super::factory::interface::ILaunchpadFactoryProviderDispatcherTrait;
use super::super::super::launchpad::interface::ILaunchpadDispatcherTrait;
use openmark::launchpad::interface::{
    ILaunchpadDispatcher, ILaunchpadProviderDispatcherTrait, ILaunchpadProviderDispatcher,
    ILaunchpadManagerDispatcher, ILaunchpadManagerDispatcherTrait, ILaunchpadHelperDispatcher,
    ILaunchpadHelperDispatcherTrait,
};
use openzeppelin::utils::serde::SerializedAppend;
use openzeppelin::token::erc721::interface::{IERC721DispatcherTrait, IERC721Dispatcher};
use openzeppelin::token::erc20::interface::{IERC20Dispatcher, IERC20DispatcherTrait};
use openzeppelin::access::accesscontrol::interface::{
    IAccessControlDispatcher, IAccessControlDispatcherTrait
};

use snforge_std::{
    declare, ContractClassTrait, start_cheat_caller_address, stop_cheat_caller_address,
    start_cheat_block_timestamp, DeclareResultTrait
};
use starknet::{ContractAddress};
use openmark::tests::unit::common::{
    SELLER1, BUYER1, BUYER2, TEST_PAYMENT, toAddress, setup_balance_at, NFT_NAME, NFT_SYMBOL,
    NFT_BASE_URI, create_launchpad_factory
};
use openmark::primitives::types::{Stage};
use openmark::primitives::constants::{MINTER_ROLE};
use openmark::primitives::utils::{get_commission};
use openmark::factory::interface::{
    ILaunchpadFactoryDispatcherTrait, ILaunchpadFactoryProviderDispatcher
};

pub fn create_game_item(owner: ContractAddress) -> ContractAddress {
    let contract = declare("GameItem").unwrap().contract_class();
    let mut constructor_calldata = array![];

    constructor_calldata.append_serde(owner);
    constructor_calldata.append_serde(NFT_NAME());
    constructor_calldata.append_serde(NFT_SYMBOL());
    constructor_calldata.append_serde(NFT_BASE_URI());
    constructor_calldata.append_serde(1000000_u256);

    let (contract_address, _) = contract.deploy(@constructor_calldata).unwrap();
    contract_address
}

fn create_launchpad(
    owner: ContractAddress
) -> (ContractAddress, ILaunchpadDispatcher, ContractAddress, ContractAddress) {
    let owner = toAddress(SELLER1);
    let lockAmount = 1000_u128;
    let payment_token = setup_balance_at(toAddress(TEST_PAYMENT));

    let lockPaymentTokens = array![payment_token].span();

    let (factory_address, factory_contract) = create_launchpad_factory(
        owner, lockAmount, payment_token, lockPaymentTokens
    );

    let erc20_dispatcher = IERC20Dispatcher { contract_address: payment_token };
    start_cheat_caller_address(payment_token, owner);
    erc20_dispatcher.approve(factory_address, 10000000);
    stop_cheat_caller_address(payment_token);

    let nft_token: ContractAddress = create_game_item(owner);
    start_cheat_caller_address(factory_address, owner);

    factory_contract.create_launchpad(0, toAddress(SELLER1), "https://starknet.io");
    let factory_provider = ILaunchpadFactoryProviderDispatcher {
        contract_address: factory_address
    };

    let launchpad_address = factory_provider.getLaunchpad(0);

    (
        launchpad_address,
        ILaunchpadDispatcher { contract_address: launchpad_address },
        payment_token,
        nft_token
    )
}

fn setup_stage(
    num_stage: u32, seller: ContractAddress, buyers: Span<ContractAddress>
) -> (ContractAddress, ILaunchpadDispatcher, ContractAddress, ContractAddress, Span<Stage>) {
    let (launchpad_address, launchpad_contract, payment_address, nft_address) = create_launchpad(
        seller
    );

    let mut stages = array![];

    let mut i = 0;
    while i < num_stage {
        stages
            .append(
                Stage {
                    id: i.into(),
                    collection: nft_address,
                    payment: payment_address,
                    price: 1,
                    maxAllocation: 10,
                    limit: 6,
                    startTime: 10,
                    endTime: 100,
                }
            );

        start_cheat_caller_address(payment_address, *buyers.at(i));
        let payment_dispatcher = IERC20Dispatcher { contract_address: payment_address };
        payment_dispatcher.approve(launchpad_address, 100000000);
        stop_cheat_caller_address(payment_address);

        i += 1;
    };
    start_cheat_block_timestamp(launchpad_address, 10);

    start_cheat_caller_address(nft_address, seller);
    let accesscontrol_dispatcher = IAccessControlDispatcher { contract_address: nft_address };
    accesscontrol_dispatcher.grant_role(MINTER_ROLE, launchpad_address);
    stop_cheat_caller_address(nft_address);

    start_cheat_caller_address(launchpad_address, seller);
    launchpad_contract.updateStages(stages.span(), array![Option::None].span());
    stop_cheat_caller_address(launchpad_address);
    return (launchpad_address, launchpad_contract, payment_address, nft_address, stages.span());
}

// Value generated by script `create_merkle_tree`
const ROOT: felt252 = 0x055bd56277c7f6d8a43e368d693619129eabb968848688f93585911fee73154a;

const PROOF: [
    felt252
    ; 2] = [
    0x03ab7a2f13b922344ed643f927acf82c486bab97a73fdbba9dbcddb735735cba,
    0x077787c98250e3bffdb3069d2893e2d9c7805ae48dfa687b1471c8fcaa1901d6
];

#[test]
fn update_stages_works() {
    let owner = toAddress(SELLER1);
    let (launchpad_address, launchpad_contract, payment_address, nft_address) = create_launchpad(
        owner
    );
    let id = 10;
    let new_stages = array![
        Stage {
            id: id,
            collection: nft_address,
            payment: payment_address,
            price: 1,
            maxAllocation: 10,
            limit: 10,
            startTime: 0,
            endTime: 10,
        }
    ];

    let whitelists = array![Option::Some(ROOT)];
    start_cheat_caller_address(launchpad_address, owner);
    start_cheat_caller_address(nft_address, owner);

    let accesscontrol_dispatcher = IAccessControlDispatcher { contract_address: nft_address };
    accesscontrol_dispatcher.grant_role(MINTER_ROLE, launchpad_address);

    launchpad_contract.updateStages(new_stages.span(), whitelists.span());
    let provider = ILaunchpadProviderDispatcher { contract_address: launchpad_address };
    assert(provider.getStage(id).id == id, 'Get stage failed');
    assert(provider.getActiveStage(id).id == id, 'Get active stage failed');
    assert(provider.getWhitelist(id) == Option::Some(ROOT), 'Get whitelist failed');
}

#[test]
#[should_panic(expected: ('Launchpad: stage not found',))]
fn remove_stages_works() {
    let seller = toAddress(SELLER1);
    let buyer1 = toAddress(BUYER1);

    let (launchpad_address, launchpad_contract, _, _, stages) = setup_stage(
        1, seller, array![buyer1].span()
    );
    let stage = *stages.at(0);
    start_cheat_caller_address(launchpad_address, seller);
    launchpad_contract.removeStages(array![stage.id].span());

    let provider = ILaunchpadProviderDispatcher { contract_address: launchpad_address };
    provider.getStage(0);
}

#[test]
fn update_and_whitelist_works() {
    let seller = toAddress(SELLER1);
    let buyer1 = toAddress(BUYER1);

    let (launchpad_address, launchpad_contract, _, _, stages) = setup_stage(
        1, seller, array![buyer1].span()
    );
    let stage = *stages.at(0);
    start_cheat_caller_address(launchpad_address, seller);
    let provider = ILaunchpadProviderDispatcher { contract_address: launchpad_address };
    assert(provider.getWhitelist(stage.id) == Option::None, 'Whitelist must be none');

    launchpad_contract.updateWhitelist(array![stage.id].span(), array![Option::Some(ROOT)].span());
    assert(provider.getWhitelist(stage.id) == Option::Some(ROOT), 'Whitelist incorrect');

    launchpad_contract.removeWhitelist(array![stage.id].span());
    assert(provider.getWhitelist(0) == Option::None, 'Whitelist must be none');
}


#[test]
fn verify_whitelist_works() {
    let owner = toAddress(SELLER1);
    let (contract_address, _, _, _) = create_launchpad(owner);
    let provider = ILaunchpadProviderDispatcher { contract_address };

    assert!(provider.verifyWhitelist(ROOT, PROOF.span(), toAddress(BUYER1)));
}

#[test]
fn buy_works() {
    let seller = toAddress(SELLER1);
    let buyer1 = toAddress(BUYER1);

    let (launchpad_address, launchpad_contract, payment_address, nft_address, stages) = setup_stage(
        1, seller, array![buyer1].span()
    );
    let stage = *stages.at(0);
    let amount = 2;
    let cost = stage.price * amount;

    let payment_dispatcher = IERC20Dispatcher { contract_address: payment_address };
    let nft_dispatcher = IERC721Dispatcher { contract_address: nft_address };

    let buyer_before_balance = payment_dispatcher.balance_of(buyer1);
    let seller_before_balance = payment_dispatcher.balance_of(launchpad_address);

    start_cheat_caller_address(launchpad_address, buyer1);
    launchpad_contract.buy(stage.id, amount, array![].span());

    let buyer_after_balance = payment_dispatcher.balance_of(buyer1);
    let seller_after_balance = payment_dispatcher.balance_of(launchpad_address);

    // Verify balance
    assert(nft_dispatcher.owner_of(0) == buyer1, 'NFT owner incorrect');
    assert(nft_dispatcher.owner_of(1) == buyer1, 'NFT owner incorrect');

    assert(buyer_after_balance == buyer_before_balance - cost.into(), 'Buyer balance incoorect');
    assert(seller_after_balance == seller_before_balance + cost.into(), 'Seller balance incoorect');

    // Verify states
    let provider = ILaunchpadProviderDispatcher { contract_address: launchpad_address };
    assert(provider.getMintedCount(stage.id) == amount.into(), 'Minted count incorrect');
    assert(
        provider.getUserMintedCount(buyer1, stage.id) == amount.into(),
        'User minted count incorrect'
    );
}

#[test]
fn buy_with_whitelist_works() {
    let seller = toAddress(SELLER1);
    let buyer1 = toAddress(BUYER1);

    let (launchpad_address, launchpad_contract, payment_address, nft_address, stages) = setup_stage(
        1, seller, array![buyer1].span()
    );
    let stage = *stages.at(0);
    let amount = 2;
    let cost = stage.price * amount;

    let payment_dispatcher = IERC20Dispatcher { contract_address: payment_address };
    let nft_dispatcher = IERC721Dispatcher { contract_address: nft_address };

    let buyer_before_balance = payment_dispatcher.balance_of(buyer1);
    let seller_before_balance = payment_dispatcher.balance_of(launchpad_address);

    start_cheat_caller_address(launchpad_address, seller);
    launchpad_contract.updateWhitelist(array![stage.id].span(), array![Option::Some(ROOT)].span());

    start_cheat_caller_address(launchpad_address, buyer1);
    launchpad_contract.buy(stage.id, amount, PROOF.span());

    let buyer_after_balance = payment_dispatcher.balance_of(buyer1);
    let seller_after_balance = payment_dispatcher.balance_of(launchpad_address);

    // Verify balance
    assert(nft_dispatcher.owner_of(0) == buyer1, 'NFT owner incorrect');
    assert(nft_dispatcher.owner_of(1) == buyer1, 'NFT owner incorrect');

    assert(buyer_after_balance == buyer_before_balance - cost.into(), 'Buyer balance incorrect');
    assert(seller_after_balance == seller_before_balance + cost.into(), 'Seller balance incorrect');

    // Verify states
    let provider = ILaunchpadProviderDispatcher { contract_address: launchpad_address };
    assert(provider.getMintedCount(stage.id) == amount.into(), 'Minted count incorrect');
    assert(
        provider.getUserMintedCount(buyer1, stage.id) == amount.into(),
        'User minted count incorrect'
    );
}

#[test]
fn withdraw_sales_works() {
    let owner = toAddress(SELLER1);
    let buyer = toAddress(BUYER1);
    let sales = 100;
    let (launchpad_address, _, payment_address, _) = create_launchpad(owner);

    let payment_dispatcher = IERC20Dispatcher { contract_address: payment_address };
    start_cheat_caller_address(payment_address, buyer);
    payment_dispatcher.transfer(launchpad_address, sales);
    stop_cheat_caller_address(payment_address);

    let owner_before_balance = payment_dispatcher.balance_of(owner);

    start_cheat_caller_address(launchpad_address, owner);
    let manager_dispatcher = ILaunchpadManagerDispatcher { contract_address: launchpad_address };

    manager_dispatcher.withdrawSales(array![payment_address].span());

    let helper_dispatcher = ILaunchpadHelperDispatcher { contract_address: launchpad_address };
    let (_, deposit_amount) = helper_dispatcher.launchpadDeposit();

    let factory_address = helper_dispatcher.getFactory();
    let fee = sales * get_commission(factory_address).into() / 1000;
    let payout = sales - fee;

    assert(
        payment_dispatcher.balance_of(owner) == owner_before_balance + payout,
        'Owner balance incorrect'
    );
    assert(
        payment_dispatcher.balance_of(factory_address) == fee.into(),
        'Launchpad balance incorrect'
    );
    assert(
        payment_dispatcher.balance_of(launchpad_address) == deposit_amount.into(),
        'Launchpad balance incorrect'
    );
}

#[test]
#[should_panic(expected: ('Launchpad: sold out',))]
fn buy_sold_out_panics() {
    let seller = toAddress(SELLER1);
    let buyer1 = toAddress(BUYER1);
    let buyer2 = toAddress(BUYER2);

    let (launchpad_address, launchpad_contract, _, _, stages) = setup_stage(
        1, seller, array![buyer1].span()
    );
    let stage = *stages.at(0);

    start_cheat_caller_address(launchpad_address, buyer1);
    launchpad_contract.buy(stage.id, stage.limit, array![].span());
    start_cheat_caller_address(launchpad_address, buyer2);
    launchpad_contract.buy(stage.id, stage.limit, array![].span());
}

#[test]
#[should_panic(expected: ('Launchpad: exceed limit',))]
fn buy_exceed_limit_panics() {
    let seller = toAddress(SELLER1);
    let buyer1 = toAddress(BUYER1);

    let (launchpad_address, launchpad_contract, _, _, stages) = setup_stage(
        1, seller, array![buyer1].span()
    );
    let stage = *stages.at(0);

    start_cheat_caller_address(launchpad_address, buyer1);
    launchpad_contract.buy(stage.id, stage.limit + 1, array![].span());
}

#[test]
#[should_panic(expected: ('Launchpad: whitelist failed',))]
fn buy_whitelist_failed_panics() {
    let seller = toAddress(SELLER1);
    let buyer1 = toAddress(BUYER1);

    let (launchpad_address, launchpad_contract, _, _, stages) = setup_stage(
        1, seller, array![buyer1].span()
    );
    start_cheat_caller_address(launchpad_address, seller);
    launchpad_contract.updateWhitelist(array![0].span(), array![Option::Some(ROOT)].span());
    let stage = *stages.at(0);

    start_cheat_caller_address(launchpad_address, buyer1);
    launchpad_contract.buy(stage.id, 1, array![].span());
}

#[test]
#[should_panic(expected: ('Launchpad: stage not started',))]
fn buy_stage_not_started_panics() {
    let seller = toAddress(SELLER1);
    let buyer1 = toAddress(BUYER1);

    let (launchpad_address, launchpad_contract, _, _, stages) = setup_stage(
        1, seller, array![buyer1].span()
    );
    let stage = *stages.at(0);
    start_cheat_block_timestamp(launchpad_address, (stage.startTime - 1).try_into().unwrap());

    start_cheat_caller_address(launchpad_address, buyer1);
    launchpad_contract.buy(stage.id, 1, array![].span());
}

#[test]
#[should_panic(expected: ('Launchpad: stage has ended',))]
fn buy_stage_ended_panics() {
    let seller = toAddress(SELLER1);
    let buyer1 = toAddress(BUYER1);

    let (launchpad_address, launchpad_contract, _, _, stages) = setup_stage(
        1, seller, array![buyer1].span()
    );
    let stage = *stages.at(0);
    start_cheat_block_timestamp(launchpad_address, (stage.endTime + 1).try_into().unwrap());

    start_cheat_caller_address(launchpad_address, buyer1);
    launchpad_contract.buy(stage.id, 1, array![].span());
}

#[test]
#[should_panic(expected: ('ERC20: insufficient balance',))]
fn buy_insufficient_balance_panics() {
    let seller = toAddress(SELLER1);
    let no_money_buyer = 0x1.try_into().unwrap();

    let (launchpad_address, launchpad_contract, _, _, stages) = setup_stage(
        1, seller, array![no_money_buyer].span()
    );
    let stage = *stages.at(0);
    start_cheat_caller_address(launchpad_address, no_money_buyer);
    launchpad_contract.buy(stage.id, 1, array![].span());
}

#[test]
#[should_panic(expected: ('Caller is not the owner',))]
fn update_stages_not_owner_panics() {
    let seller = toAddress(SELLER1);
    let buyer1 = toAddress(BUYER1);
    let not_owner = 0x1.try_into().unwrap();

    let (launchpad_address, launchpad_contract, payment_address, nft_address, _) = setup_stage(
        1, seller, array![buyer1].span()
    );

    start_cheat_caller_address(launchpad_address, not_owner);
    let new_stages = array![
        Stage {
            id: 0,
            collection: nft_address,
            payment: payment_address,
            price: 1,
            maxAllocation: 10,
            limit: 1,
            startTime: 0,
            endTime: 0,
        }
    ];
    launchpad_contract.updateStages(new_stages.span(), array![Option::Some(ROOT)].span());
}

#[test]
#[should_panic(expected: ('Caller is not the owner',))]
fn remove_stages_not_owner_panics() {
    let seller = toAddress(SELLER1);
    let buyer1 = toAddress(BUYER1);
    let not_owner = 0x1.try_into().unwrap();

    let (launchpad_address, launchpad_contract, _, _, stages) = setup_stage(
        1, seller, array![buyer1].span()
    );
    let stage = *stages.at(0);

    start_cheat_caller_address(launchpad_address, not_owner);
    launchpad_contract.removeStages(array![stage.id].span());
}

#[test]
#[should_panic(expected: ('Caller is not the owner',))]
fn update_whitelist_not_owner_panics() {
    let seller = toAddress(SELLER1);
    let buyer1 = toAddress(BUYER1);
    let not_owner = 0x1.try_into().unwrap();

    let (launchpad_address, launchpad_contract, _, _, stages) = setup_stage(
        1, seller, array![buyer1].span()
    );
    let stage = *stages.at(0);

    start_cheat_caller_address(launchpad_address, not_owner);
    launchpad_contract.updateWhitelist(array![stage.id].span(), array![Option::None].span());
}

#[test]
#[should_panic(expected: ('Caller is not the owner',))]
fn remove_whitelist_not_owner_panics() {
    let seller = toAddress(SELLER1);
    let buyer1 = toAddress(BUYER1);
    let not_owner = 0x1.try_into().unwrap();

    let (launchpad_address, launchpad_contract, _, _, stages) = setup_stage(
        1, seller, array![buyer1].span()
    );
    let stage = *stages.at(0);

    start_cheat_caller_address(launchpad_address, not_owner);
    launchpad_contract.removeWhitelist(array![stage.id].span());
}

#[test]
#[should_panic(expected: ('Caller is not the owner',))]
fn withdraw_sales_not_owner_panics() {
    let seller = toAddress(SELLER1);
    let buyer1 = toAddress(BUYER1);
    let not_owner = 0x1.try_into().unwrap();

    let (launchpad_address, _, payment_address, _, _) = setup_stage(
        1, seller, array![buyer1].span()
    );
    start_cheat_caller_address(launchpad_address, not_owner);
    let manager_dispatcher = ILaunchpadManagerDispatcher { contract_address: launchpad_address };

    manager_dispatcher.withdrawSales(array![payment_address].span());
}
